{
  "version": 3,
  "sources": ["../xen-state.js", "../xen-template.js", "../xen-element.js", "../xen-base.js", "../xen-debug.js", "../xen.js", "../xen-async.js"],
  "sourcesContent": [
    "/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nconst nob = () => Object.create(null);\nconst debounce = (key, action, delay) => {\n  if (key) {\n    clearTimeout(key);\n  }\n  if (action && delay) {\n    return setTimeout(action, delay);\n  }\n};\nconst XenStateMixin = Base => class extends (Base ?? class {}) {\n  constructor() {\n    super();\n    this._pendingProps = nob();\n    this._props = this._getInitialProps() || nob();\n    this._lastProps = nob();\n    this._state = this._getInitialState() || nob();\n    this._lastState = nob();\n  }\n  _getInitialProps() {\n  }\n  _getInitialState() {\n  }\n  _getProperty(name) {\n    return this._pendingProps[name] || this._props[name];\n  }\n  _setProperty(name, value) {\n    // dirty checking opportunity\n    if (this._validator || this._wouldChangeProp(name, value)) {\n      this._pendingProps[name] = value;\n      this._invalidateProps();\n    }\n  }\n  _wouldChangeValue(map, name, value) {\n    // Important dirty-checking behavior controlled here,\n    // can be overridden.\n    // The default implementation will use strict reference checking.\n    // To modify structured values one must create a new Object to\n    // replace the old one.\n    return (map[name] !== value);\n    // an example of dirty-checking that instead simply punts on structured data\n    //return (typeof value === 'object') || (map[name] !== value);\n  }\n  _wouldChangeProp(name, value) {\n    return this._wouldChangeValue(this._props, name, value);\n  }\n  _wouldChangeState(name, value) {\n    return this._wouldChangeValue(this._state, name, value);\n  }\n  _setProps(props) {\n    // TODO(sjmiles): should be a replace instead of a merge?\n    Object.assign(this._pendingProps, props);\n    this._invalidateProps();\n  }\n  _invalidateProps() {\n    this._propsInvalid = true;\n    this._invalidate();\n  }\n  mergeState(object) {\n    let dirty = false;\n    const state = this._state;\n    for (const property in object) {\n      const value = object[property];\n      if (this._wouldChangeState(property, value)) {\n        dirty = true;\n        state[property] = value;\n      }\n    }\n    if (dirty) {\n      this._invalidate();\n      return true;\n    }\n  }\n  // BC\n  _setState(object) {\n    return this.mergeState(object);\n  }\n  _async(fn) {\n    // Promise.resolve() lets the micro-queue task roll, while blocking the task-queue,\n    // so it's \"faster\" to turn-around than setTimeout\n    return Promise.resolve().then(fn.bind(this));\n  }\n  asyncTask(waitMs, fn) {\n    // setTimeout lets the task queue roll, which is important for not locking up the thread,\n    // but it's \"slower\" to turn-around than Promise.resolve\n    return setTimeout(fn, Number(waitMs) || 0);\n  }\n  _invalidate() {\n    if (!this._validator) {\n      this._validator = this._async(this._validate);\n    }\n  }\n  _getStateArgs() {\n    return [this._props, this._state, this._lastProps, this._lastState];\n  }\n  _validate() {\n    const stateArgs = this._getStateArgs();\n    // try..catch to ensure we nullify `validator` before return\n    try {\n      // TODO(sjmiles): should be a replace instead of a merge\n      Object.assign(this._props, this._pendingProps);\n      if (this._propsInvalid) {\n        // TODO(sjmiles): should/can have different timing from rendering?\n        this._willReceiveProps(...stateArgs);\n        this._propsInvalid = false;\n      }\n      if (this._shouldUpdate(...stateArgs)) {\n        // TODO(sjmiles): consider throttling update to rAF\n        this._ensureMount();\n        this._doUpdate(...stateArgs);\n      }\n    } catch (x) {\n      console.error(x);\n    }\n    // nullify validator _after_ methods so state changes don't reschedule validation\n    this._validator = null;\n    // save the old props and state\n    this._lastProps = Object.assign(nob(), this._props);\n    this._lastState = Object.assign(nob(), this._state);\n  }\n  _doUpdate(...stateArgs) {\n    this._update(...stateArgs);\n    this._didUpdate(...stateArgs);\n  }\n  _ensureMount() {\n  }\n  _willReceiveProps() {\n  }\n  _shouldUpdate() {\n    return true;\n  }\n  _update() {\n  }\n  _didUpdate() {\n  }\n  _debounce(key, func, delay) {\n    key = `_debounce_${key}`;\n    this._state[key] = debounce(this._state[key], func, delay != null ? delay : 16);\n  }\n};\nexport {XenStateMixin, nob, debounce};",
  "/**\n * @license\n * Copyright (c) 2016 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/* Annotator */\n// tree walker that generates arbitrary data using visitor function `cb`\n// `cb` is called as `cb(node, key, notes)`\n// where\n//   `node` is a visited node.\n//   `key` is a handle which identifies the node in a map generated by `Annotator.locateNodes`.\nclass Annotator {\n    constructor(cb) {\n      this.cb = cb;\n    }\n    // For subtree at `node`, produce annotation object `notes`.\n    // the content of `notes` is completely determined by the behavior of the\n    // annotator callback function supplied at the constructor.\n    annotate(node, notes, opts) {\n      this.notes = notes;\n      this.opts = opts || 0;\n      this.key = this.opts.key || 0;\n      notes.locator = this._annotateSubtree(node);\n      return notes;\n    }\n    // walking subtree at `node`\n    _annotateSubtree(node) {\n      let childLocators;\n      for (let i = 0, child = node.firstChild, previous = null, neo; child; i++) {\n        // returns a locator only if a node in the subtree requires one\n        const childLocator = this._annotateNode(child);\n        // only when necessary, maintain a sparse array of locators\n        if (childLocator) {\n          (childLocators = childLocators || {})[i] = childLocator;\n        }\n        // `child` may have been evacipated by visitor\n        neo = previous ? previous.nextSibling : node.firstChild;\n        if (neo === child) {\n          previous = child;\n          child = child.nextSibling;\n        } else {\n          child = neo;\n          i--;\n        }\n      }\n      // is falsey unless there was at least one childLocator\n      return childLocators;\n    }\n    _annotateNode(node) {\n      // visit node\n      const key = this.key++;\n      const shouldLocate = this.cb(node, key, this.notes, this.opts);\n      // recurse\n      const locators = this._annotateSubtree(node);\n      if (shouldLocate || locators) {\n        const cl = Object.create(null);\n        cl.key = key;\n        if (locators) {\n          cl.sub = locators;\n        }\n        return cl;\n      }\n    }\n  }\n  const locateNodes = function(root, locator, map) {\n    map = map || [];\n    for (const n in locator) {\n      const loc = locator[n];\n      if (loc) {\n        const node = root.childNodes[n];\n        // TODO(sjmiles): text-nodes sometimes evacipate when stamped, so map to the parentElement instead\n        map[loc.key] = (node.nodeType === Node.TEXT_NODE) ? node.parentElement : node;\n        if (loc.sub) {\n          // recurse\n          locateNodes(node, loc.sub, map);\n        }\n      }\n    }\n    return map;\n  };\n  /* Annotation Producer */\n  // must return `true` for any node whose key we wish to track\n  const annotatorImpl = function(node, key, notes, opts) {\n    let tracking = false;\n    // hook\n    if (opts.annotator && opts.annotator(node, key, notes, opts)) {\n      tracking = true;\n    }\n    // default\n    switch (node.nodeType) {\n      case Node.DOCUMENT_FRAGMENT_NODE:\n        break;\n      case Node.ELEMENT_NODE:\n        return tracking || annotateElementNode(node, key, notes);\n      case Node.TEXT_NODE:\n        return tracking || annotateTextNode(node, key, notes);\n    }\n    return tracking;\n  };\n  const annotateTextNode = function(node, key, notes) {\n    if (annotateMustache(node, key, notes, 'textContent', node.textContent)) {\n      node.textContent = '';\n      return true;\n    }\n  };\n  const annotateElementNode = function(node, key, notes) {\n    if (node.hasAttributes()) {\n      let noted = false;\n      for (let a$ = node.attributes, i = a$.length - 1, a; i >= 0 && (a = a$[i]); i--) {\n        if (\n          annotateEvent(node, key, notes, a.name, a.value) ||\n          annotateMustache(node, key, notes, a.name, a.value) ||\n          annotateDirective(node, key, notes, a.name, a.value)\n        ) {\n          node.removeAttribute(a.name);\n          noted = true;\n        }\n      }\n      return noted;\n    }\n  };\n  const annotateMustache = function(node, key, notes, property, mustache) {\n    if (mustache.slice(0, 2) === '{{') {\n      if (property === 'class') {\n        property = 'className';\n      }\n      let value = mustache.slice(2, -2);\n      // TODO(sjmiles): MWDC components use event-names of the form `MDCTabBar:activated`, which breaks the usage\n      // of `:` as delimiter. So, instead of `on-faux=\"MDCTabBar:activated:onActivated\"` support\n      // `on-faux=\"MDCTabBar:activated=onActivated\"`\n      const delim = mustache.includes('=') ? '=' : ':';\n      const override = value.split(delim);\n      if (override.length === 2) {\n        property = override[0];\n        value = override[1];\n      }\n      takeNote(notes, key, 'mustaches', property, value);\n      if (value[0] === '$') {\n        takeNote(notes, 'xlate', value, true);\n      }\n      return true;\n    }\n  };\n  const annotateEvent = function(node, key, notes, name, value) {\n    if (name.slice(0, 3) === 'on-') {\n      if (value.slice(0, 2) === '{{') {\n        value = value.slice(2, -2);\n        console.warn(\n          `Xen: event handler for '${name}' expressed as a mustache, which is not supported. Using literal value '${value}' instead.`\n        );\n      }\n      takeNote(notes, key, 'events', name.slice(3), value);\n      return true;\n    }\n  };\n  const annotateDirective = function(node, key, notes, name, value) {\n    if (name === 'xen:forward') {\n      takeNote(notes, key, 'events', 'xen:forward', value);\n      return true;\n    }\n  };\n  const takeNote = function(notes, key, group, name, note) {\n    const n$ = notes[key] || (notes[key] = Object.create(null));\n    (n$[group] || (n$[group] = {}))[name] = note;\n  };\n  const annotator = new Annotator(annotatorImpl);\n  const annotate = function(root, key, opts) {\n    return (root._notes ||\n      (root._notes = annotator.annotate(root.content, {/*ids:{}*/}, key, opts))\n    );\n  };\n  /* Annotation Consumer */\n  const mapEvents = function(notes, map, mapper) {\n    // add event listeners\n    for (const key in notes) {\n      const node = map[key];\n      const events = notes[key] && notes[key].events;\n      if (node && events) {\n        for (const event in events) {\n          let name = event;\n          let value = events[name];\n          // TODO(sjmiles): MWDC components use event-names of the form `MDCTabBar:activated`, support\n          // `on-faux=\"MDCTabBar:activated=onActivated\"`.\n          // I thought we had this feature already, not sure what happened.\n          if (value.includes('=')) {\n            [name, value] = value.split('=');\n          }\n          mapper(node, name, value);\n        }\n      }\n    }\n  };\n  const listen = function(controller, node, eventName, handlerName) {\n    node.addEventListener(eventName, function(e) {\n      if (controller[handlerName]) {\n        return controller[handlerName](e, e.detail);\n      } else if (controller.defaultHandler) {\n        return controller.defaultHandler(handlerName, e);\n      }\n    });\n  };\n  const set = function(notes, map, scope, controller) {\n    if (scope) {\n      for (const key in notes) {\n        const node = map[key];\n        if (node) {\n          // everybody gets a scope\n          node.scope = scope;\n          // now get your regularly scheduled bindings\n          const mustaches = notes[key].mustaches;\n          for (const name in mustaches) {\n            const property = mustaches[name];\n            if (property in scope) {\n              _set(node, name, scope[property], controller);\n            }\n          }\n        }\n      }\n    }\n  };\n  const _set = function(node, property, value, controller) {\n    // TODO(sjmiles): the property conditionals here could be precompiled\n    const modifier = property.slice(-1);\n    if (property === 'style%' || property === 'style' || property === 'xen:style') {\n      if (typeof value === 'string') {\n        node.style.cssText = value;\n      } else {\n        Object.assign(node.style, value);\n      }\n    } else if (modifier == '$') {\n      const n = property.slice(0, -1);\n      if (typeof value === 'boolean' || value === undefined || value === null) {\n        setBoolAttribute(node, n, Boolean(value));\n      } else {\n        node.setAttribute(n, value);\n      }\n    } else if (property === 'textContent') {\n      if (value?.$template || value?.template || Array.isArray(value) || value?.models) {\n        _setSubTemplate(node, value, controller);\n      } else {\n        const isPrimitiveValue = value !== null && value !== undefined && (typeof value !== 'object') && (typeof value !== 'function');\n        node.textContent = isPrimitiveValue ? value : '';\n      }\n    } else if (property === 'unsafe-html') {\n      node.innerHTML = value || '';\n    } else if (property === 'value') {\n      // TODO(sjmiles): specifically dirty-check `value` to avoid resetting input elements\n      if (node.value !== value) {\n        node.value = value;\n      }\n    }\n    else if (property === 'focus' && node.focus) {\n      node.focus();\n    }\n    // TODO(sjmiles): hack for image elements, needs more discernment\n    else if (property === 'src') {\n      node.src = value || '';\n    } else {\n      node[property] = value;\n    }\n  };\n  const setBoolAttribute = function(node, attr, state) {\n    node[\n      (state === undefined ? !node.hasAttribute(attr) : state)\n        ? 'setAttribute'\n        : 'removeAttribute'\n    ](attr, '');\n  };\n  const _setSubTemplate = function(node, value, controller) {\n    // TODO(sjmiles): subtemplate iteration ability specially implemented to support xenon (serialization boundary)\n    // TODO(sjmiles): Aim to re-implement as a plugin.\n    let {template, $template: templateName, models} = value;\n    if (Array.isArray(value)) {\n      models = value;\n    }\n    if (!template) {\n      const name = templateName || node?.getAttribute('repeat');\n      template = node.getRootNode().querySelector(`template[${name}]`);\n    } else {\n      template = maybeStringToTemplate(template);\n    }\n    _renderSubtemplates(node, controller, template, models/* || $models*/);\n  };\n  const _renderSubtemplates = function(container, controller, template, models) {\n    let child = container.firstElementChild;\n    let next;\n    if (template && models) {\n      models && models.forEach((model, i)=>{\n        next = child && child.nextElementSibling;\n        // use existing node if possible\n        if (!child) {\n          const dom = stamp(template).events(controller);\n          child = dom.root.firstElementChild;\n          if (child) {\n            child._subtreeDom = dom;\n            container.appendChild(child);\n            if (!template._shapeWarning && dom.root.firstElementChild) {\n              template._shapeWarning = true;\n              console.warn(`xen-template: subtemplate has multiple root nodes: only the first is used.`, template);\n            }\n          }\n        }\n        if (child) {\n          child._subtreeDom.set(model);\n          child = next;\n        }\n      });\n    }\n    // remove extra nodes\n    while (child) {\n      next = child.nextElementSibling;\n      child.remove();\n      child = next;\n    }\n  };\n  //window.stampCount = 0;\n  //window.stampTime = 0;\n  const stamp = function(template, opts) {\n    //const startTime = performance.now();\n    //window.stampCount++;\n    template = maybeStringToTemplate(template);\n    // construct (or use memoized) notes\n    const notes = annotate(template, opts);\n    // CRITICAL TIMING ISSUE #1:\n    // importNode can have side-effects, like CustomElement callbacks (before we\n    // can do any work on the imported subtree, before we can mapEvents, e.g.).\n    // we could clone into an inert document (say a new template) and process the nodes\n    // before importing if necessary.\n    const root = document.importNode(template.content, true);\n    // templates don't require a single container element, but sometimes they do have one...\n    // capture the first element, because it's harder to find after we insert the nodes into DOM\n    const firstElement = root.firstElementChild;\n    // map DOM to keys\n    const map = locateNodes(root, notes.locator);\n    // return dom manager\n    const dom = {\n      root,\n      notes,\n      map,\n      firstElement,\n      $(slctr) {\n        return this.root.querySelector(slctr);\n      },\n      $$(slctr) {\n        return this.root.querySelectorAll(slctr);\n      },\n      set: function(scope) {\n        scope && set(notes, map, scope, this.controller);\n        return this;\n      },\n      events: function(controller) {\n        // TODO(sjmiles): originally `controller` was expected to be an Object with event handler\n        // methods on it (typically a custom-element stamping a template).\n        // In Xenon, we want to attach a generic handler (Function) for any event on this node.\n        // Subtemplate stamping gets involved because they need to reuse whichever controller.\n        // I suspect this can be simplified, but right now I'm just making it go.\n        if (controller && typeof controller !== 'function') {\n          controller = listen.bind(this, controller);\n        }\n        this.controller = controller;\n        if (controller) {\n          mapEvents(notes, map, controller);\n        }\n        return this;\n      },\n      // support event-forwarding when stamping descendent template DOM\n      // i.e. for objects (say, elements) that consume templates as input\n      // see also: support for `xen:forward` attribute above\n      forward: function() {\n        mapEvents(notes, map, (node, eventName, handlerName) => {\n          node.addEventListener(eventName, e => {\n            //console.log(`xen::forward: forwarding [${eventName}]`);\n            const wrapper = {eventName, handlerName, detail: e.detail, target: e.target};\n            fire(node, 'xen:forward', wrapper, {bubbles: true});\n          });\n        });\n        return this;\n      },\n      appendTo: function(node) {\n        if (this.root) {\n          // TODO(sjmiles): assumes this.root is a fragment\n          node.appendChild(this.root);\n        } else {\n          console.warn('Xen: cannot appendTo, template stamped no DOM');\n        }\n        // TODO(sjmiles): this.root is no longer a fragment\n        this.root = node;\n        return this;\n      }\n    };\n    //window.stampTime += performance.now() - startTime;\n    return dom;\n  };\n  const fire = (node, eventName, detail, init) => {\n    const eventInit = init || {};\n    eventInit.detail = detail;\n    const event = new CustomEvent(eventName, eventInit);\n    node.dispatchEvent(event);\n    return event.detail;\n  };\n  const maybeStringToTemplate = template => {\n    // TODO(sjmiles): need to memoize this somehow\n    return (typeof template === 'string') ? createTemplate(template) : template;\n  };\n  const createTemplate = innerHTML => {\n    return Object.assign(document.createElement('template'), {innerHTML});\n  };\n  export const Template = {\n    createTemplate,\n    setBoolAttribute,\n    stamp,\n    takeNote\n  };",
  "/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nexport const XenElementMixin = Base => class extends Base {\n  constructor() {\n    super();\n    this._mounted = false;\n    this._root = this;\n    this.__configureAccessors();\n    this.__lazyAcquireProps();\n  }\n  get _class() {\n    // TODO(sjmiles): problem accessing class statics under polyfills can be fixed\n    // by attaching _class reference to element constructors (not provided)\n    return (this.constructor._class || this.constructor);\n  }\n  __configureAccessors() {\n    // only do this once per prototype\n    const p = Object.getPrototypeOf(this);\n    if (!p.hasOwnProperty('__$xenPropsConfigured')) {\n      p.__$xenPropsConfigured = true;\n      const a = this._class.observedAttributes;\n      a && a.forEach(n => {\n        Object.defineProperty(p, n, {\n          get() {\n            return this._getProperty(n); // abstract\n          },\n          set(value) {\n            this._setProperty(n, value); // abstract\n          }\n        });\n      });\n    }\n  }\n  __lazyAcquireProps() {\n    const a = this._class.observedAttributes;\n    a && a.forEach(n=>{\n      if (n.toLowerCase() !== n) {\n        console.error(`Xen: Mixed-case attributes are not yet supported, \"${this.localName}.observedAttributes\" contains \"${n}\".`);\n      }\n      if (this.hasOwnProperty(n)) {\n        const value = this[n];\n        delete this[n];\n        this[n] = value;\n      } else if (this.hasAttribute(n)) {\n        this._setValueFromAttribute(n, this.getAttribute(n));\n      }\n    });\n  }\n  // provide hook for type coercion (attributes are always String valued)\n  _setValueFromAttribute(name, value) {\n    this[name] = value;\n  }\n  connectedCallback() {\n    this._mount();\n  }\n  _mount() {\n    if (!this._mounted) {\n      this._mounted = true;\n      this._doMount();\n      this._didMount();\n    }\n  }\n  _doMount() {\n  }\n  _didMount() {\n  }\n  _fire(eventName, detail, node, init) {\n    const eventInit = init || {};\n    eventInit.detail = detail;\n    const event = new CustomEvent(eventName, eventInit);\n    (node || this).dispatchEvent(event);\n    return event.detail;\n  }\n};\n",
  "/**\n * @license\n * Copyright 2019 Google LLC.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport {XenStateMixin} from './xen-state.js';\nimport {XenElementMixin} from './xen-element.js';\nimport {Template} from './xen-template.js';\nconst {HTMLElement} = globalThis;\nexport const XenBaseMixin = (Base) => class extends Base {\n  get template() {\n    const module = this.constructor.module;\n    return module ? module.querySelector('template') : '';\n  }\n  get host() {\n    return this.shadowRoot || this.attachShadow({mode: `open`});\n  }\n  _doMount() {\n    this._stamp();\n    this._invalidate();\n  }\n  _stamp() {\n    if (this.template) {\n      // TODO(sjmiles): can just do `events(this)` for default listener, but we use a custom listener\n      // so we can append (props, state) to handler signature. All we are really altering is the delegation,\n      // not the listening, maybe there could be another customization point just for that. Perhaps the default\n      // listener could invoke a delegator if it exists, then fallback to original behavior.\n      this._dom = Template.stamp(this.template).events(this._listener.bind(this)).appendTo(this.host);\n    }\n  }\n  _listener(node, name, handler) {\n    node.addEventListener(name, e => {\n      if (this[handler]) {\n        return this[handler](e, e.detail, this._props, this._state);\n      }\n    });\n  }\n  _doUpdate(...stateArgs) {\n    this._update(...stateArgs);\n    let model = this._render(...stateArgs);\n    if (this._dom) {\n      if (Array.isArray(model)) {\n        model = model.reduce((sum, value) => Object.assign(sum, value), Object.create(null));\n      }\n      this._dom.set(model);\n    }\n    this._didUpdate(...stateArgs);\n    this._didRender(...stateArgs);\n  }\n  _render() {\n  }\n  _didRender() {\n  }\n};\nexport const XenBase = XenBaseMixin(XenElementMixin(XenStateMixin(HTMLElement)));\n",
  "/**\n * @license\n * Copyright 2019 Google LLC.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nexport const Debug = (Base, log) => class extends Base {\n    _setProperty(name, value) {\n      if (Debug.level > 1) {\n        if (((name in this._pendingProps) && (this._pendingProps[name] !== value)) || (this._props[name] !== value)) {\n          log('props', deepishClone({[name]: value}));\n        }\n      }\n      return super._setProperty(name, value);\n    }\n    _setState(state) {\n      if (typeof state !== 'object') {\n        console.warn(`Xen::_setState argument must be an object`);\n        return false;\n      }\n      if (super._setState(state)) {\n        if (Debug.level > 1) {\n          if (Debug.lastFire) {\n            //Debug.lastFire.log('[next state change from] fire', {[Debug.lastFire.name]: Debug.lastFire.detail});\n            //Debug.lastFire.log('fire', Debug.lastFire.name, Debug.lastFire.detail);\n            log('(fired -->) state', deepishClone(state));\n          } else {\n            log('state', deepishClone(state));\n          }\n        }\n        return true;\n      }\n    }\n    _setImmutableState(name, value) {\n      log('state [immutable]', {[name]: value});\n      super._setImmutableState(name, value);\n    }\n    _fire(name, detail, node, init) {\n      Debug.lastFire = {name, detail: deepishClone(detail), log};\n      log('fire', {[Debug.lastFire.name]: Debug.lastFire.detail});\n      super._fire(name, detail, node, init);\n      Debug.lastFire = null;\n    }\n    _doUpdate(...args) {\n      if (Debug.level > 2) {\n        log('updating...');\n      }\n      return super._doUpdate(...args);\n    }\n    _invalidate() {\n      if (Debug.level > 2) {\n        if (!this._validator) {\n          log('invalidating...');\n        }\n      }\n      super._invalidate();\n    }\n  };\n  // TODO(sjmiles): cloning prevents console log from showing values from the future,\n  // but this must be a deep clone. Circular objects are not cloned.\n  const deepishClone = (obj, depth) => {\n    if (!obj || typeof obj !== 'object') {\n      return obj;\n    }\n    const clone = Object.create(null);\n    for (const n in obj) {\n      let value = obj[n];\n      //try {\n      //  value = JSON.parse(JSON.stringify(value));\n      //} catch (x) {\n        if (depth < 1) {\n          value = deepishClone(obj, (depth || 0) + 1);\n        }\n      //}\n      clone[n] = value;\n    }\n    return clone;\n  };\n  Debug.level = 0;\n  const _logFactory = (preamble, color, log='log') => console[log].bind(console, `%c${preamble}`, `background: ${color}; color: white; padding: 1px 6px 2px 7px; border-radius: 6px;`);\n  export const logFactory = (preamble, color, log) => (Debug.level > 0) ? _logFactory(preamble, color, log) : () => {};\n  export const walker = (node, tree) => {\n    let subtree = tree;\n    if (!subtree) {\n      subtree = {};\n    }\n    const root = node || document.body;\n    let index = 1;\n    let child = root.firstElementChild;\n    while (child) {\n      const name = child.localName;\n      const clas = customElements.get(name);\n      if (clas) {\n        const shadow = child.shadowRoot;\n        const record = {\n          node: child,\n          props: child._props,\n          state: child._state\n        };\n        const children = shadow ? walker(shadow) : {};\n        if (children) {\n          record.children = children;\n        }\n        let moniker = `${name}${child.id ? `#${child.id}` : ``} (${index++})`;\n        while (subtree[moniker]) {\n          moniker += '_';\n        }\n        subtree[moniker] = record;\n      }\n      walker(child, subtree);\n      child = child.nextElementSibling;\n    }\n    return subtree;\n  };",
  "/**\n * @license\n * Copyright 2023 NeonFlan LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport {Template} from './xen-template.js';\nimport {XenStateMixin, debounce, nob} from './xen-state.js';\nimport {XenElementMixin} from './xen-element.js';\nimport {XenBaseMixin, XenBase} from './xen-base.js';\nimport {Debug, logFactory, walker} from './xen-debug.js';\n// helper for editors that can syntax highlight html template strings\nconst html = (strings, ...values) => {\n  return (strings[0] + values.map((v, i) => v + strings[i + 1]).join('')).trim();\n};\nTemplate.html = (...args) => Template.createTemplate(html(...args));\nconst clone = obj => typeof obj === 'object' ? Object.assign(Object.create(null), obj) : {};\n// TODO(sjmiles): properties of Xen include some classes as mixins, some as resolved, we should\n// be more explicit\nconst Xen = {\n  State: XenStateMixin,\n  Template,\n  Element: XenElementMixin,\n  BaseMixin: XenBaseMixin,\n  Base: XenBase,\n  Debug,\n  setBoolAttribute: Template.setBoolAttribute,\n  html,\n  walker,\n  logFactory,\n  clone,\n  nob,\n  debounce\n};\nglobalThis.Xen = Xen;\nexport default Xen;",
  "/**\n * @license\n * Copyright 2023 NeonFlan LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport Xen from './xen.js';\nconst XenAsyncMixin = Base => class extends Base {\n  // shorthand for adding state,\n  // `this.state = state` is equivalent to `this._setState(state)`\n  set state(state) {\n    this._setState(state);\n  }\n  get state() {\n    return this._state;\n  }\n  get props() {\n    return this._props;\n  }\n  async(fn) {\n    return this._async(fn);\n  }\n  invalidate(fn) {\n    return this._invalidate(fn);\n  }\n  // store result `await operation()` into state[name],\n  // making sure to only invoke `operation` once even if\n  // `awaitState` is called multiple times\n  async awaitState(name, operation) {\n    const state = this._state;\n    const semaphore = `_await_${name}`;\n    //console.warn('awaitState', name, state[semaphore]);\n    if (!state[semaphore]) {\n      state[semaphore] = true;\n      const value = await operation();\n      this.state = {[name]: value, [semaphore]: false};\n    }\n  }\n  // underscore relief\n  fire(...args) {\n    return this._fire(...args);\n  }\n  _getInitialState() {\n    return this.getInitialState && this.getInitialState();\n  }\n  _update(props, state, oldProps, oldState) {\n    return this.update && this.update(props, state, oldProps, oldState);\n  }\n  _render(props, state, oldProps, oldState) {\n    if (this.shouldRender(props, state, oldProps, oldState)) {\n      return this.render && this.render(props, state, oldProps, oldState);\n    }\n  }\n  shouldRender() {\n    return true;\n  }\n  render(props, state) {\n    return state;\n  }\n  // event->state utility\n  onState(e, data) {\n    this._setState({[e.type]: data});\n  }\n};\nXen.AsyncMixin = XenAsyncMixin;\nXen.Async = XenAsyncMixin(Xen.Base);\nexport {Xen, XenAsyncMixin};"
  ],
  "mappings": "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",
  "debugId": "177682B700CD3AE164756e2164756e21",
  "names": []
}