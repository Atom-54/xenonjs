<!DOCTYPE html>

<script type="importmap">{
  "imports": {
    "libp2p/": "../../../third-party/libp2p/"
  }
}</script>

<input style="width: 80%" placeholder="multiaddress" id="ma" value="/ip4/127.0.0.1/tcp/59958/ws/p2p/12D3KooWJCJWhLh2eLSDd2nBwLkc6ueegFQZutFBi8TWwmGYko7L"><br>
<button onclick="doConnect()">Connect</button>
<hr>
<div id="sendSection" style="display:none;">
  <input style="width: 80%;" placeholder="message" id="message" value="Hello"><br>
  <button onclick="doSend()">Send</button>
  <hr>
</div>

<h3>Connections</h3>
<div id="connections"></div>
<h3>Multiaddrs</h3>
<div id="multiaddrs"></div>

<script type="module">
  import {
    createLibp2p,
    identifyService,
    webRTC,
    webSockets, filters,
    mplex,
    bootstrap,
    noise,
    yamux,
    multiaddr, protocols,
    circuitRelayTransport
  } from 'libp2p/bundle.min.js';

const WEBRTC_CODE = protocols('webrtc').code

// Known peers addresses
const bootstrapMultiaddrs = [
  '/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb',
  '/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN'
];

const node = await createLibp2p({
  addresses: {
    listen: [
      '/webrtc'
    ]
  },
  transports: [
    webSockets({
      filter: filters.all
    }),
    webRTC(),
    circuitRelayTransport({
      discoverRelays: 1
    })
  ],
  connectionEncryption: [noise()],
  streamMuxers: [mplex()],
  connectionGater: {
    denyDialMultiaddr: () => {
      // by default we refuse to dial local addresses from the browser since they
      // are usually sent by remote peers broadcasting undialable multiaddrs but
      // here we are explicitly connecting to a local node so do not deny dialing
      // any discovered address
      return false
    }
  },
  services: {
    identify: identifyService()
  }
});

await node.start();

// handle the echo protocol
await node.handle("/echo/1.0.0", ({ stream }) => {
  pipe(
    stream,
    async function* (source) {
      for await (const buf of source) {
        const incoming = toString(buf.subarray())
        appendOutput(`Received message '${clean(incoming)}'`)
        yield buf
      }
    },
    stream
  )
});

function updateConnList() {
  // Update connections list
  const connListEls = node
    .getConnections()
    .map((connection) => {
      if (connection.remoteAddr.protoCodes().includes(WEBRTC_CODE)) {
        sendSection.style.display = "block"
      }

      const el = document.createElement("li")
      el.textContent = connection.remoteAddr.toString()
      return el
    })
    ;
  globalThis.connections.replaceChildren(...connListEls);
};

node.addEventListener("connection:open", (event) => {
  updateConnList();
});

node.addEventListener("connection:close", (event) => {
  updateConnList();
});

node.addEventListener("self:peer:update", (event) => {
  // Update multiaddrs list
  const multiaddrs = node.getMultiaddrs()
    .map((ma) => {
      const el = document.createElement("li")
      el.textContent = ma.toString()
      return el
    })
  ;
  globalThis.multiaddrs.replaceChildren(...multiaddrs);
});

const isWebrtc = (ma) => {
  return ma.protoCodes().includes(WEBRTC_CODE)
};

const appendOutput = console.log.bind(console);

globalThis.doConnect = async () => {
  const ma = multiaddr(window.ma.value);
  const connection = await node.dial(ma);
  if (isWebrtc(ma)) {
    const outgoing_stream = await connection.newStream(["/echo/1.0.0"])
    pipe(sender, outgoing_stream, async (src) => {
      for await (const buf of src) {
        const response = toString(buf.subarray())
        appendOutput(`Received message '${clean(response)}'`)
      }
    })
  }
  appendOutput(`Connected to '${ma}'`)
};

// Wait for connection and relay to be bind for the example purpose
// node.addEventListener('self:peer:update', (evt) => {
//   // Updated self multiaddrs?
//   console.log(`Advertising with a relay address of ${node.getMultiaddrs()[0].toString()}`)
// })

//node.getMultiaddrs().forEach((ma) => console.log(ma.toString()))

// const ma =  multiaddr('/ip4/127.0.0.1/tcp/51975/ws/p2p/12D3KooWSDp5xvrgubiKhPPbp5SbgXRpiYB57YmoTSf5yhfMajUs')
// const stream = await node.dialProtocol(ma, ['/xen-protocol/1.0.0'])

// const message = `Hello js-libp2p-webrtc\n`
// const response = await pipe([fromString(message)], stream, async (source) => await first(source))
// const responseDecoded = toString(response.slice(0, response.length))

</script>