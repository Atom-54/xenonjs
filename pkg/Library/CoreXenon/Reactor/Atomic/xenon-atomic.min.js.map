{
  "version": 3,
  "sources": ["js/core/EventEmitter.js", "js/utils/object.js", "js/utils/rand.js", "js/core/Decorator.js", "js/core/Host.js", "js/utils/utils.js", "js/utils/id.js", "js/utils/paths.js", "src/xenon-atomic.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2023 NeonFlan LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nexport class EventEmitter {\n    // map of event name to listener array\n    listeners = {};\n    getEventListeners(eventName) {\n        return this.listeners[eventName] || (this.listeners[eventName] = []);\n    }\n    fire(eventName, ...args) {\n        const listeners = this.getEventListeners(eventName);\n        if (listeners?.forEach) {\n            listeners.forEach(listener => listener(...args));\n        }\n    }\n    listen(eventName, listener, listenerName) {\n        if (!listener) {\n            console.warn('Got a null listener', eventName);\n            return;\n        }\n        const listeners = this.getEventListeners(eventName);\n        listeners.push(listener);\n        listener._name = listenerName || '(unnamed listener)';\n        return listener;\n    }\n    unlisten(eventName, listener) {\n        const list = this.getEventListeners(eventName);\n        const index = (typeof listener === 'string') ? list.findIndex(l => l._name === listener) : list.indexOf(listener);\n        if (index >= 0) {\n            list.splice(index, 1);\n        }\n        else {\n            console.warn('failed to unlisten from', eventName);\n        }\n    }\n}\n", "/**\n * @license\n * Copyright 2023 NeonFlan LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n/*\n* update the fields of `obj` with the fields of `data`,\n* perturbing `obj` as little as possible (since it might be a magic proxy thing\n* like an Automerge document)\n*/\nexport const shallowUpdate = (obj, data) => {\n  let result = data;\n  if (!data) {\n    //\n  }\n  else if (Array.isArray(data)) {\n    if (!Array.isArray(obj)) {\n      // TODO(sjmiles): eek, very perturbing to obj\n      obj = [];\n    }\n    for (let i = 0; i < data.length; i++) {\n      const value = data[i];\n      if (obj[i] !== value) {\n        obj[i] = value;\n      }\n    }\n    const overage = obj.length - data.length;\n    if (overage > 0) {\n      obj.splice(data.length, overage);\n    }\n  }\n  else if (typeof data === 'object') {\n    result = (obj && typeof obj === 'object') ? obj : Object.create(null);\n    const seen = {};\n    // for each key in input data ...\n    Object.keys(data).forEach(key => {\n      // copy that data into output\n      result[key] = data[key];\n      // remember the key\n      seen[key] = true;\n    });\n    // for each key in the output data...\n    Object.keys(result).forEach(key => {\n      // if this key was not in the input, remove it\n      if (!seen[key]) {\n        delete result[key];\n      }\n    });\n  }\n  return result;\n};\n\nexport const shallowMerge = (obj, data) => {\n  if (data == null) {\n    return null;\n  }\n  if (typeof data === 'object') {\n    const result = (obj && typeof obj === 'object') ? obj : Object.create(null);\n    Object.keys(data).forEach(key => result[key] = data[key]);\n    return result;\n  }\n  return data;\n};\n\nexport const deepMerge = (obj, data) => {\n  if (data !== null) {\n    if (typeof data === 'object' && !Array.isArray(data)) {\n      const result = (obj && typeof obj === 'object') ? obj : Object.create(null);\n      Object.keys(data).forEach(key => result[key] = deepMerge(result[key], data[key]));\n      return result;\n    }\n    return data\n  }\n  return obj;\n};\n\nexport function deepCopy(datum) {\n  if (!datum) {\n    return datum;\n  }\n  else if (Array.isArray(datum)) {\n    // This is trivially type safe but tsc needs help\n    return datum.map(element => deepCopy(element));\n  }\n  else if (typeof datum === 'object') {\n    // downstream code may expect Object.prototype\n    const clone = {}; //Object.create(null);\n    Object.entries(datum).forEach(([key, value]) => {\n      clone[key] = deepCopy(value);\n    });\n    return clone;\n  }\n  else {\n    return datum;\n  }\n}\n\nexport const deepEqual = (a, b) => {\n  const type = typeof a;\n  // must be same type to be equal\n  if (type !== typeof b) {\n    return false;\n  }\n  // we are `deep` because we recursively study object types\n  if (type === 'object' && a && b) {\n    const aProps = Object.getOwnPropertyNames(a);\n    const bProps = Object.getOwnPropertyNames(b);\n    // equal if same # of props, and no prop is not deepEqual\n    return (aProps.length == bProps.length) && !aProps.some(name => !deepEqual(a[name], b[name]));\n  }\n  // finally, perform simple comparison\n  return (a === b);\n};\n\nexport const deepUndefinedToNull = (obj) => {\n  if (obj === undefined) {\n    return null;\n  }\n  if (obj && (typeof obj === 'object')) {\n    // we are `deep` because we recursively study object types\n    const props = Object.getOwnPropertyNames(obj);\n    props.forEach(name => {\n      const prop = obj[name];\n      if (prop === undefined) {\n        delete obj[name];\n        //obj[name] = null;\n      }\n      else {\n        deepUndefinedToNull(prop);\n      }\n    });\n  }\n  return obj;\n};\n", "/**\n * @license\n * Copyright 2023 NeonFlan LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst { floor, pow, random } = Math;\n// random n-digit number\nexport const key = (digits) => floor((1 + random() * 9) * pow(10, digits - 1));\n// random integer from [0..range)\nexport const irand = (range) => floor(random() * range);\n// random element from array\nexport const arand = (array) => array[irand(array.length)];\n// test if event has occured, where `probability` is between [0..1]\nexport const prob = (probability) => Boolean(random() < probability);\n", "/**\n * @license\n * Copyright 2023 NeonFlan LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport {deepCopy} from '../utils/object.js';\n\nconst {values, entries} = Object;\nconst opaqueData = {};\nconst log = logf('Decorator', 'plum');\n\nexport const Decorator = {\n  setOpaqueData(name, data) {\n    opaqueData[name] = data; //deepCopy(data);\n    return name;\n  },\n  getOpaqueData(name) {\n    return opaqueData[name];\n  },\n  maybeDecorateModel(model, atom) {\n    if (model && !Array.isArray(model)) {\n      // for each item in model, regardless of key\n      values(model).forEach((item) => {\n        // is an object?\n        if (item && (typeof item === 'object')) {\n          // are there sub-models\n          if (item['models']) {\n            // the decorate this item\n            log('applying decorator(s) to list:', item);\n            this.maybeDecorateItem(item, atom);\n          }\n          else {\n            // otherwise, check if there are sub-items to decorate\n            if (model?.filter || model?.decorator || model?.collateBy) {\n              log('scanning for lists in sub-model:', item);\n              this.maybeDecorateModel(item, atom);\n            }\n          }\n        }\n      });\n    }\n    // possibly decorated model\n    return model;\n  },\n  maybeDecorateItem(item, atom) {\n    let models = (typeof item.models === 'string') ? this.getOpaqueData(item.models) : item.models;\n    if (models) {\n      // do a decorator\n      models = maybeDecorate(models, item.decorator, atom);\n      // do a filter\n      models = maybeFilter(models, item.filter, atom.impl);\n      // do a collator\n      models = maybeCollateBy(models, item);\n      // mutate items\n      item.models = models;\n      //console.log(JSON.stringify(models, null, '  '));\n    }\n  },\n};\nconst maybeDecorate = (models, decorator, atom) => {\n  decorator = atom.impl[decorator] ?? decorator;\n  const { inputs, state } = atom.internal;\n  if (decorator) {\n    // TODO(cromwellian): Could be expensive to do everything, store responsibility?\n    const immutableInputs = Object.freeze(deepCopy(inputs));\n    // we don't want the decorator to have access to mutable globals\n    const immutableState = Object.freeze(deepCopy(state));\n    // models become decorous\n    models = models.map(model => {\n      // use previously mutated data or initialize\n      // TODO(cromwellian): I'd like to do Object.freeze() here, also somehow not mutate the models inplace\n      // Possibly have setOpaqueData wrap the data so the privateData lives on the wrapper + internal immutable data\n      model.privateData = model.privateData || {};\n      // TODO(cromwellian): also could be done once during setOpaqueData() if we can track privateData differently\n      const immutableModel = Object.freeze(deepCopy(model));\n      const decorated = decorator(immutableModel, immutableInputs, immutableState);\n      // set new privateData from returned\n      model.privateData = decorated.privateData;\n      return { ...decorated, ...model, };\n    });\n    // sort (possible that all values undefined)\n    models.sort(sortByLc('sortKey'));\n    log('decoration was performed');\n  }\n  //models.forEach(model => delete model.privateData);\n  return models;\n};\nconst maybeFilter = (models, filter, impl) => {\n  filter = impl[filter] ?? filter;\n  if (filter && models) {\n    // models become filtrated\n    models = models.filter(filter);\n  }\n  return models;\n};\nconst maybeCollateBy = (models, item) => {\n  // construct requested sub-lists\n  entries(item).forEach(([name, collator]) => {\n    // generate named collations for items of the form `[name]: {collateBy}`\n    if (collator?.['collateBy']) {\n      // group the models into buckets based on the model-field named by `collateBy`\n      const collation = collate(models, collator['collateBy']);\n      models = collationToRenderModels(collation, name, collator['$template']);\n    }\n  });\n  return models;\n};\nconst sortByLc = key => (a, b) => sort(String(a[key]).toLowerCase(), String(b[key]).toLowerCase());\n//const sortBy = key => (a, b) => sort(a[key], b[key]);\nconst sort = (a, b) => a < b ? -1 : a > b ? 1 : 0;\nconst collate = (models, collateBy) => {\n  const collation = {};\n  models.forEach(model => {\n    const keyValue = model[collateBy];\n    if (keyValue) {\n      const category = collation[keyValue] || (collation[keyValue] = []);\n      category.push(model);\n    }\n  });\n  return collation;\n};\nconst collationToRenderModels = (collation, name, $template) => {\n  return entries(collation).map(([key, models]) => ({\n    key,\n    [name]: { models, $template },\n    single: !(models['length'] !== 1),\n    ...models?.[0]\n  }));\n};\n", "/**\n * @license\n * Copyright 2023 NeonFlan LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport {deepEqual, deepCopy} from '../utils/object.js';\nimport {arand} from '../utils/rand.js';\nimport {EventEmitter} from './EventEmitter.js';\nimport {Decorator} from './Decorator.js';\nconst {entries, keys} = Object;\n\nconst customLogFactory = id => logf(`Host (${id})`, arand(logColors));\nconst logColors = ['#5a189a', '#51168b', '#48137b', '#6b2fa4', '#7b46ae', '#3f116c'];\n//const customLogFactory = (id) => logFactory(logFactory.flags.host, `Host (${id})`, arand(['#5a189a', '#51168b', '#48137b', '#6b2fa4', '#7b46ae', '#3f116c']));\n\n/**\n * Host owns metadata (e.g. `id`, `container`) that its Atom is not allowed to access.\n * Host knows how to talk, asynchronously, to its Atom (potentially using a bus).\n**/\n/* TODO(sjmiles):\nUpdate Cycle Documented Briefly\n1. when a Store changes it invokes it's listeners\n2. when an App hears a Store change, it updates Hosts bound to the Store\n3. App updates Host by creating an `inputs` object from Stores and metadata\n   - ignores fact inputs are accumulated\n   - ignores information about which Store has updated\n4. `inputs` object is assigned to `hosts.inputs` \n5. Host does an expensive `deepEqual` equality check. Turning on `host` logging should reveal `this.log('inputs are not interesting, skipping update');` if data is caught in this trap\n   - we can use reference testing here if we are more careful\n     about using immutable data\n6. the atom.inputs are assigned (but is really a *merge*)\n*/\nexport class Host extends EventEmitter {\n  id;\n  lastInputs;\n  lastOutput;\n  lastPacket;\n  lastRenderModel;\n  log;\n  meta;\n  atom;\n  constructor(id) {\n    super();\n    this.log = customLogFactory(id);\n    this.id = id;\n    this.name = id;\n  }\n  dispose() {\n    this.detach();\n  }\n  onevent(eventlet) {\n    this.fire('eventlet', eventlet);\n  }\n  // Atom and AtomMeta are separate, host specifically integrates these on behalf of Atom\n  installAtom(atom, meta) {\n    if (this.atom) {\n      this.detachAtom();\n    }\n    if (atom) {\n      this.atom = atom;\n      this.meta = meta || this.meta;\n    }\n  }\n  get container() {\n    return this.meta?.container || 'root';\n  }\n  detach() {\n    this.detachAtom();\n  }\n  detachAtom() {\n    if (this.atom) {\n      this.render({ $clear: true });\n      this.atom = null;\n      this.meta = null;\n    }\n  }\n  async service(request) {\n    if (request?.decorate) {\n      return Decorator.maybeDecorateModel(request.model, this.atom);\n    }\n    if (request) {\n      const promise = new Promise(resolve => \n        request.resolve = value => {\n          delete request.resolve;\n          resolve(value);\n        }\n      );\n      this.fire('service', request);\n      return promise;\n    }\n  }\n  output(outputModel, renderModel) {\n    if (outputModel) {\n      this.lastOutput = outputModel;\n      this.fire('output', outputModel);\n    }\n    if (this.template) {\n      Decorator.maybeDecorateModel(renderModel, this.atom);\n      this.lastRenderModel = { ...renderModel };\n      // 'render' event is sent from 'render()'\n      this.render(renderModel);\n    }\n  }\n  rerender() {\n    // does not re-render Frame/Slot content\n    if (this.lastRenderModel) {\n      this.render(this.lastRenderModel);\n    }\n  }\n  render(model) {\n    const { id, container, template } = this;\n    const content = { model, template };\n    const packet = { id, container, content };\n    this.fire('render', packet);\n    this.lastPacket = packet;\n  }\n  /**/\n  set inputs(inputs) {\n    if (this.atom && inputs) {\n      //let lastInputs = this.atom.internal.inputs ?? this.meta?.staticInputs ?? Object.create(null);\n      let lastInputs = this.lastInputs ?? Object.create(null);\n      if (this.dirtyCheck(inputs, lastInputs, this.lastOutput)) {\n        this.lastInputs = this.atom.inputs = deepCopy({...lastInputs, ...inputs});\n        //this.fire('inputs-changed');\n      }\n    }\n  }\n  dirtyCheck(inputs, lastInputs, lastOutput) {\n    const dirtyBits = ([n, v]) => (lastOutput?.[n] && !deepEqual(lastOutput[n], v))\n      || !deepEqual(lastInputs?.[n], v)\n      ;\n    return !lastInputs\n      || entries(inputs).length !== this.lastInputsLength(lastInputs)\n      || entries(inputs).some(dirtyBits)\n      ;\n  }\n  lastInputsLength(lastInputs) {\n    return keys(lastInputs).filter(key => !this.meta?.staticInputs?.[key] && key !== 'eventlet').length;\n  }\n  get config() {\n    return this.atom?.config;\n  }\n  get template() {\n    return this.config?.template;\n  }\n  hasTemplate() {\n    return Boolean(this.template);\n  }\n  invalidate() {\n    this.atom?.invalidate();\n  }\n  handleEvent(eventlet) {\n    return this.atom?.handleEvent(eventlet);\n  }\n}\n", "/**\n * @license\n * Copyright 2023 NeonFlan LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n//export * from './date.js';\nexport * from './id.js';\n//export * from './log.js';\n//export * from './matching.js';\nexport * from './object.js';\nexport * from './paths.js';\n//export * from './rand.js';\n//export * from './task.js';\n", "/**\n * @license\n * Copyright 2023 NeonFlan LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport {irand} from \"./rand.js\";\n\nexport const makeId = (pairs, digits, delim) => {\n  pairs = pairs || 2;\n  digits = digits || 2;\n  delim = delim || '-';\n  const min = Math.pow(10, digits - 1);\n  const range = Math.pow(10, digits) - min;\n  const result = [];\n  for (let i = 0; i < pairs; i++) {\n      result.push(`${irand(range - min) + min}`);\n  }\n  return result.join(delim);\n};\n", "/**\n * @license\n * Copyright 2023 NeonFlan LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nexport const PathMapper = class {\n  map;\n  constructor(root) {\n    this.map = {};\n    this.setRoot(root);\n  }\n  add(mappings) {\n    Object.assign(this.map, mappings || {});\n  }\n  resolve(path) {\n    let last;\n    do {\n      path = this._resolve(last = path);\n    } while (last !== path);\n    return path;\n  }\n  _resolve(path) {\n    const bits = path.split('/');\n    const top = bits.shift();\n    const prefix = this.map[top] || top;\n    return [prefix, ...bits].join('/');\n  }\n  setRoot(root) {\n    if (root.length && root[root.length - 1] === '/') {\n      root = root.slice(0, -1);\n    }\n    this.add({\n      '$root': root,\n      '$xenon': root\n    });\n  }\n  getAbsoluteHereUrl(meta, depth) {\n    // you are here\n    const localRelative = meta.url.split('/').slice(0, -(depth ?? 1)).join('/');\n    if (!globalThis?.document) {\n      return localRelative;\n    }\n    else {\n      // document root is here\n      let base = document.URL;\n      // if document URL has a filename, remove it\n      if (base[base.length - 1] !== '/') {\n          base = `${base.split('/').slice(0, -1).join('/')}/`;\n      }\n      // create absoute path to here (aka 'local')\n      let localAbsolute = new URL(localRelative, base).href;\n      // no trailing slash!\n      if (localAbsolute[localAbsolute.length - 1] === '/') {\n          localAbsolute = localAbsolute.slice(0, -1);\n      }\n      return localAbsolute;\n    }\n  }\n};\n\nconst root = ''; //import.meta?.url?.split('/').slice(0, -3).join('/');\nexport const Paths = globalThis['Paths'] = new PathMapper(root ?? '');\nPaths.add(globalThis.config?.paths);\n", "/**\n * @license\n * Copyright 2023 NeonFlan LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n//export * from '../js/logf.js';\n// export * from '../js/AtomFactory.js';\nexport * from '../js/core/EventEmitter.js';\nexport * from '../js/core/Host.js';\n\n// import {AtomFactory} from '../js/AtomFactory.js';\n// export const Runtime = AtomFactory;\n\nimport * as utils from '../js/utils/utils.js';\nconst {Paths} = utils;\nexport {Paths, utils};\n\n"],
  "mappings": "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",
  "names": ["EventEmitter", "eventName", "args", "listeners", "listener", "listenerName", "list", "index", "l", "shallowUpdate", "obj", "data", "result", "i", "value", "overage", "seen", "key", "shallowMerge", "deepMerge", "deepCopy", "datum", "element", "clone", "deepEqual", "a", "b", "type", "aProps", "bProps", "name", "deepUndefinedToNull", "prop", "floor", "pow", "random", "irand", "range", "floor", "random", "arand", "array", "values", "entries", "opaqueData", "log", "Decorator", "name", "data", "model", "atom", "item", "models", "maybeDecorate", "maybeFilter", "maybeCollateBy", "decorator", "inputs", "state", "immutableInputs", "deepCopy", "immutableState", "immutableModel", "decorated", "sortByLc", "filter", "impl", "collator", "collation", "collate", "collationToRenderModels", "key", "a", "b", "sort", "collateBy", "keyValue", "$template", "entries", "keys", "customLogFactory", "id", "arand", "logColors", "Host", "EventEmitter", "eventlet", "atom", "meta", "request", "Decorator", "promise", "resolve", "value", "outputModel", "renderModel", "model", "container", "template", "packet", "inputs", "lastInputs", "deepCopy", "lastOutput", "dirtyBits", "n", "v", "deepEqual", "key", "utils_exports", "__export", "PathMapper", "Paths", "deepCopy", "deepEqual", "deepMerge", "deepUndefinedToNull", "makeId", "shallowMerge", "shallowUpdate", "makeId", "pairs", "digits", "delim", "min", "range", "result", "irand", "PathMapper", "root", "mappings", "path", "last", "bits", "top", "meta", "depth", "localRelative", "base", "localAbsolute", "Paths", "Paths", "utils_exports"]
}
