var e=Object.defineProperty,r={};((r,t)=>{for(var n in t)e(r,n,{get:t[n],enumerable:!0})})(r,{audioClassification:()=>c,automaticSpeechRecognition:()=>u,conversational:()=>b,documentQuestionAnswering:()=>O,featureExtraction:()=>h,fillMask:()=>A,imageClassification:()=>f,imageSegmentation:()=>p,imageToImage:()=>m,imageToText:()=>w,objectDetection:()=>l,questionAnswering:()=>x,request:()=>a,sentenceSimilarity:()=>v,streamingRequest:()=>s,summarization:()=>_,tableQuestionAnswering:()=>E,tabularClassification:()=>W,tabularRegression:()=>I,textClassification:()=>k,textGeneration:()=>T,textGenerationStream:()=>j,textToImage:()=>d,textToSpeech:()=>y,tokenClassification:()=>C,translation:()=>S,visualQuestionAnswering:()=>U,zeroShotClassification:()=>q});var t="https://api-inference.huggingface.co/models/";function n(e,r){const{model:n,accessToken:a,...o}=e,s={};a&&(s.Authorization=`Bearer ${a}`);const i="data"in e&&!!e.data;i?(r?.wait_for_model&&(s["X-Wait-For-Model"]="true"),!1===r?.use_cache&&(s["X-Use-Cache"]="false"),r?.dont_load_model&&(s["X-Load-Model"]="0")):s["Content-Type"]="application/json";return{url:/^http(s?):/.test(n)||n.startsWith("/")?n:`${t}${n}`,info:{headers:s,method:"POST",body:i?e.data:JSON.stringify({...o,options:r}),credentials:r?.includeCredentials?"include":"same-origin"}}}async function a(e,r){const{url:t,info:o}=n(e,r),s=await(r?.fetch??fetch)(t,o);if(!1!==r?.retry_on_error&&503===s.status&&!r?.wait_for_model)return a(e,{...r,wait_for_model:!0});if(!s.ok){if(s.headers.get("Content-Type")?.startsWith("application/json")){const e=await s.json();if(e.error)throw new Error(e.error)}throw new Error("An error occurred while fetching the blob")}return s.headers.get("Content-Type")?.startsWith("application/json")?await s.json():await s.blob()}function o(e){let r,t,n,a=!1;return function(o){void 0===r?(r=o,t=0,n=-1):r=function(e,r){const t=new Uint8Array(e.length+r.length);return t.set(e),t.set(r,e.length),t}(r,o);const s=r.length;let i=0;for(;t<s;){a&&(10===r[t]&&(i=++t),a=!1);let o=-1;for(;t<s&&-1===o;++t)switch(r[t]){case 58:-1===n&&(n=t-i);break;case 13:a=!0;case 10:o=t}if(-1===o)break;e(r.subarray(i,o),n),i=t,n=-1}i===s?r=void 0:0!==i&&(r=r.subarray(i),t-=i)}}async function*s(e,r){const{url:t,info:a}=n({...e,stream:!0},r),i=await(r?.fetch??fetch)(t,a);if(!1!==r?.retry_on_error&&503===i.status&&!r?.wait_for_model)return s(e,{...r,wait_for_model:!0});if(!i.ok){if(i.headers.get("Content-Type")?.startsWith("application/json")){const e=await i.json();if(e.error)throw new Error(e.error)}throw new Error(`Server response contains error: ${i.status}`)}if("text/event-stream"!==i.headers.get("content-type"))throw new Error("Server does not support event stream content type, it returned "+i.headers.get("content-type"));if(!i.body)return;const c=i.body.getReader();let u=[];const y=o(function(e,r,t){let n={data:"",event:"",id:"",retry:void 0};const a=new TextDecoder;return function(o,s){if(0===o.length)t?.(n),n={data:"",event:"",id:"",retry:void 0};else if(s>0){const t=a.decode(o.subarray(0,s)),i=s+(32===o[s+1]?2:1),c=a.decode(o.subarray(i));switch(t){case"data":n.data=n.data?n.data+"\n"+c:c;break;case"event":n.event=c;break;case"id":e(n.id=c);break;case"retry":const t=parseInt(c,10);isNaN(t)||r(n.retry=t)}}}}((()=>{}),(()=>{}),(e=>{u.push(e)})));try{for(;;){const{done:e,value:r}=await c.read();if(e)return;y(r);for(const e of u)if(e.data.length>0){const r=JSON.parse(e.data);if("object"==typeof r&&null!==r&&"error"in r)throw new Error(r.error);yield r}u=[]}}finally{c.releaseLock()}}var i=class extends TypeError{constructor(e){super(`Invalid inference output: ${e}. Use the 'request' method with the same parameters to do a custom call with no type checking.`),this.name="InferenceOutputError"}};async function c(e,r){const t=await a(e,r);if(!(Array.isArray(t)&&t.every((e=>"string"==typeof e.label&&"number"==typeof e.score))))throw new i("Expected Array<{label: string, score: number}>");return t}async function u(e,r){const t=await a(e,r);if(!("string"==typeof t?.text))throw new i("Expected {text: string}");return t}async function y(e,r){const t=await a(e,r);if(!(t&&t instanceof Blob))throw new i("Expected Blob");return t}async function f(e,r){const t=await a(e,r);if(!(Array.isArray(t)&&t.every((e=>"string"==typeof e.label&&"number"==typeof e.score))))throw new i("Expected Array<{label: string, score: number}>");return t}async function p(e,r){const t=await a(e,r);if(!(Array.isArray(t)&&t.every((e=>"string"==typeof e.label&&"string"==typeof e.mask&&"number"==typeof e.score))))throw new i("Expected Array<{label: string, mask: string, score: number}>");return t}async function w(e,r){const t=(await a(e,r))?.[0];if("string"!=typeof t?.generated_text)throw new i("Expected {generated_text: string}");return t}async function l(e,r){const t=await a(e,r);if(!(Array.isArray(t)&&t.every((e=>"string"==typeof e.label&&"number"==typeof e.score&&"number"==typeof e.box.xmin&&"number"==typeof e.box.ymin&&"number"==typeof e.box.xmax&&"number"==typeof e.box.ymax))))throw new i("Expected Array<{label:string; score:number; box:{xmin:number; ymin:number; xmax:number; ymax:number}}>");return t}async function d(e,r){const t=await a(e,r);if(!(t&&t instanceof Blob))throw new i("Expected Blob");return t}function g(e){if(globalThis.Buffer)return globalThis.Buffer.from(e).toString("base64");{const r=[];return e.forEach((e=>{r.push(String.fromCharCode(e))})),globalThis.btoa(r.join(""))}}async function m(e,r){let t;t=e.parameters?{...e,inputs:g(new Uint8Array(e.inputs instanceof ArrayBuffer?e.inputs:await e.inputs.arrayBuffer()))}:{accessToken:e.accessToken,model:e.model,data:e.inputs};const n=await a(t,r);if(!(n&&n instanceof Blob))throw new i("Expected Blob");return n}async function b(e,r){const t=await a(e,r);if(!(Array.isArray(t.conversation.generated_responses)&&t.conversation.generated_responses.every((e=>"string"==typeof e))&&Array.isArray(t.conversation.past_user_inputs)&&t.conversation.past_user_inputs.every((e=>"string"==typeof e))&&"string"==typeof t.generated_text&&Array.isArray(t.warnings)&&t.warnings.every((e=>"string"==typeof e))))throw new i("Expected {conversation: {generated_responses: string[], past_user_inputs: string[]}, generated_text: string, warnings: string[]}");return t}async function h(e,r){const t=await a(e,r);let n=!0;const o=(e,r,t=0)=>!(t>r)&&(e.every((e=>Array.isArray(e)))?e.every((e=>o(e,r,t+1))):e.every((e=>"number"==typeof e)));if(n=Array.isArray(t)&&o(t,2,0),!n)throw new i("Expected Array<number[][] | number[] | number>");return t}async function A(e,r){const t=await a(e,r);if(!(Array.isArray(t)&&t.every((e=>"number"==typeof e.score&&"string"==typeof e.sequence&&"number"==typeof e.token&&"string"==typeof e.token_str))))throw new i("Expected Array<{score: number, sequence: string, token: number, token_str: string}>");return t}async function x(e,r){const t=await a(e,r);if(!("object"==typeof t&&!!t&&"string"==typeof t.answer&&"number"==typeof t.end&&"number"==typeof t.score&&"number"==typeof t.start))throw new i("Expected {answer: string, end: number, score: number, start: number}");return t}async function v(e,r){const t=await a(e,r);if(!(Array.isArray(t)&&t.every((e=>"number"==typeof e))))throw new i("Expected number[]");return t}async function _(e,r){const t=await a(e,r);if(!(Array.isArray(t)&&t.every((e=>"string"==typeof e?.summary_text))))throw new i("Expected Array<{summary_text: string}>");return t?.[0]}async function E(e,r){const t=await a(e,r);if(!("string"==typeof t?.aggregator&&"string"==typeof t.answer&&Array.isArray(t.cells)&&t.cells.every((e=>"string"==typeof e))&&Array.isArray(t.coordinates)&&t.coordinates.every((e=>Array.isArray(e)&&e.every((e=>"number"==typeof e))))))throw new i("Expected {aggregator: string, answer: string, cells: string[], coordinates: number[][]}");return t}async function k(e,r){const t=(await a(e,r))?.[0];if(!(Array.isArray(t)&&t.every((e=>"string"==typeof e?.label&&"number"==typeof e.score))))throw new i("Expected Array<{label: string, score: number}>");return t}async function T(e,r){const t=await a(e,r);if(!(Array.isArray(t)&&t.every((e=>"string"==typeof e?.generated_text))))throw new i("Expected Array<{generated_text: string}>");return t?.[0]}async function*j(e,r){yield*s(e,r)}function B(e){return Array.isArray(e)?e:[e]}async function C(e,r){const t=B(await a(e,r));if(!(Array.isArray(t)&&t.every((e=>"number"==typeof e.end&&"string"==typeof e.entity_group&&"number"==typeof e.score&&"number"==typeof e.start&&"string"==typeof e.word))))throw new i("Expected Array<{end: number, entity_group: string, score: number, start: number, word: string}>");return t}async function S(e,r){const t=await a(e,r);if(!(Array.isArray(t)&&t.every((e=>"string"==typeof e?.translation_text))))throw new i("Expected type Array<{translation_text: string}>");return t?.[0]}async function q(e,r){const t=B(await a(e,r));if(!(Array.isArray(t)&&t.every((e=>Array.isArray(e.labels)&&e.labels.every((e=>"string"==typeof e))&&Array.isArray(e.scores)&&e.scores.every((e=>"number"==typeof e))&&"string"==typeof e.sequence))))throw new i("Expected Array<{labels: string[], scores: number[], sequence: string}>");return t}async function O(e,r){const t={...e,inputs:{question:e.inputs.question,image:g(new Uint8Array(e.inputs.image instanceof ArrayBuffer?e.inputs.image:await e.inputs.image.arrayBuffer()))}},n=B(await a(t,r))?.[0];if(!!("string"!=typeof n?.answer||"number"!=typeof n.end&&void 0!==n.end||"number"!=typeof n.score&&void 0!==n.score||"number"!=typeof n.start&&void 0!==n.start))throw new i("Expected Array<{answer: string, end?: number, score?: number, start?: number}>");return n}async function U(e,r){const t={...e,inputs:{question:e.inputs.question,image:g(new Uint8Array(e.inputs.image instanceof ArrayBuffer?e.inputs.image:await e.inputs.image.arrayBuffer()))}},n=(await a(t,r))?.[0];if(!("string"==typeof n?.answer&&"number"==typeof n.score))throw new i("Expected Array<{answer: string, score: number}>");return n}async function I(e,r){const t=await a(e,r);if(!(Array.isArray(t)&&t.every((e=>"number"==typeof e))))throw new i("Expected number[]");return t}async function W(e,r){const t=await a(e,r);if(!(Array.isArray(t)&&t.every((e=>"number"==typeof e))))throw new i("Expected number[]");return t}var $=class{accessToken;defaultOptions;constructor(e="",t={}){this.accessToken=e,this.defaultOptions=t;for(const[n,a]of Object.entries(r))Object.defineProperty(this,n,{enumerable:!1,value:(r,n)=>a({...r,accessToken:e},{...t,...n})})}endpoint(e){return new N(e,this.accessToken,this.defaultOptions)}},N=class{constructor(e,t="",n={}){for(const[a,o]of Object.entries(r))Object.defineProperty(this,a,{enumerable:!1,value:(r,a)=>o({...r,accessToken:t,model:e},{...n,...a})})}};export{$ as HfInference,N as HfInferenceEndpoint,i as InferenceOutputError,c as audioClassification,u as automaticSpeechRecognition,b as conversational,O as documentQuestionAnswering,h as featureExtraction,A as fillMask,f as imageClassification,p as imageSegmentation,m as imageToImage,w as imageToText,l as objectDetection,x as questionAnswering,a as request,v as sentenceSimilarity,s as streamingRequest,_ as summarization,E as tableQuestionAnswering,W as tabularClassification,I as tabularRegression,k as textClassification,T as textGeneration,j as textGenerationStream,d as textToImage,y as textToSpeech,C as tokenClassification,S as translation,U as visualQuestionAnswering,q as zeroShotClassification};export default null;